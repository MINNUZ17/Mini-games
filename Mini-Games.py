# -*- coding: utf-8 -*-
"""Copy of Untitled11.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10ifSYdNLbFKDOv6Sjd3lGnJhZmPtJoA1
"""

import math
import random

class TicTacToe:
    def __init__(self):
        self.board = [' ' for _ in range(9)]

    def print_board(self):
        for row in [self.board[i*3:(i+1)*3] for i in range(3)]:
            print('| ' + ' | '.join(row) + ' |')

    def available_moves(self):
        return [i for i, spot in enumerate(self.board) if spot == ' ']

    def num_empty_cells(self):
        return self.board.count(' ')

    def make_move(self, position, player):
        self.board[position] = player

    def is_winner(self, player):
        for i in range(0, 9, 3):
            if all(self.board[i+j] == player for j in range(3)):
                return True
        for i in range(3):
            if all(self.board[i+j] == player for j in range(0, 7, 3)):
                return True
        if all(self.board[i] == player for i in range(0, 9, 4)):
            return True
        if all(self.board[i] == player for i in range(2, 7, 2)):
            return True
        return False

    def game_over(self):
        return self.is_winner('X') or self.is_winner('O') or self.num_empty_cells() == 0

class DotsAndBoxes:
    def __init__(self):
        self.cols = 4
        self.rows = 4
        self.board = [[0] * self.cols for _ in range(self.rows)]
        self.horizontal_lines = [[False] * (self.cols - 1) for _ in range(self.rows + 1)]
        self.vertical_lines = [[False] * self.cols for _ in range(self.rows - 1)]
        self.player = 1

    def print_board(self):
        for i in range(self.rows):
            print(" --- " * self.cols)
            print("|", end="")
            for j in range(self.cols):
                print("   |", end="")
            print()
        print(" --- " * self.cols)

    def available_moves(self):
        moves = []
        for i in range(self.rows):
            for j in range(self.cols):
                if self.board[i][j] == 0:
                    moves.append((i, j))
        return moves

    def num_empty_cells(self):
        return sum(row.count(0) for row in self.board)

    def make_move(self, move):
        row, col = move
        self.board[row][col] = self.player
        self.player = 3 - self.player

    def is_winner(self, player):
        return self.num_empty_cells() == 0

    def game_over(self):
        return self.is_winner(1) or self.is_winner(2)

class ConnectFour:
    def __init__(self):
        self.rows = 6
        self.cols = 7
        self.board = [[' ' for _ in range(self.cols)] for _ in range(self.rows)]

    def print_board(self):
        for row in self.board:
            print('| ' + ' | '.join(row) + ' |')

    def available_moves(self):
        return [col for col in range(self.cols) if self.board[0][col] == ' ']

    def num_empty_cells(self):
        return sum(row.count(' ') for row in self.board)

    def make_move(self, col, player):
        for row in range(self.rows-1, -1, -1):
            if self.board[row][col] == ' ':
                self.board[row][col] = player
                break

    def is_winner(self, player):
        for row in range(self.rows):
            for col in range(self.cols - 3):
                if self.board[row][col] == player and self.board[row][col+1] == player and self.board[row][col+2] == player and self.board[row][col+3] == player:
                    return True
        for row in range(self.rows - 3):
            for col in range(self.cols):
                if self.board[row][col] == player and self.board[row+1][col] == player and self.board[row+2][col] == player and self.board[row+3][col] == player:
                    return True
        for row in range(self.rows - 3):
            for col in range(self.cols - 3):
                if self.board[row][col] == player and self.board[row+1][col+1] == player and self.board[row+2][col+2] == player and self.board[row+3][col+3] == player:
                    return True
        for row in range(3, self.rows):
            for col in range(self.cols - 3):
                if self.board[row][col] == player and self.board[row-1][col+1] == player and self.board[row-2][col+2] == player and self.board[row-3][col+3] == player:
                    return True
        return False

    def is_board_full(self):
        return all(self.board[0][col] != ' ' for col in range(self.cols))

class GameBot:
    def __init__(self, game_type):
        self.game_type = game_type

    def get_next_move(self, game):
        if self.game_type == 'TicTacToe':
            return self.get_tic_tac_toe_move(game)
        elif self.game_type == 'DotsAndBoxes':
            return self.get_dots_and_boxes_move(game)
        elif self.game_type == 'ConnectFour':
            return self.get_connect_four_move(game)

    def get_tic_tac_toe_move(self, game):
        best_score = -math.inf
        best_move = None
        alpha = -math.inf
        beta = math.inf
        for move in game.available_moves():
            game.make_move(move, 'O')
            score = self.minimax(game, False, alpha, beta)
            game.make_move(move, ' ')
            if score > best_score:
                best_score = score
                best_move = move
            alpha = max(alpha, best_score)
        return best_move

    def get_dots_and_boxes_move(self, game):
        return random.choice(game.available_moves())

    def get_connect_four_move(self, game):
        best_score = -math.inf
        best_move = None
        alpha = -math.inf
        beta = math.inf
        for move in game.available_moves():
            game.make_move(move, 'O')
            score = self.minimax(game, False, alpha, beta)
            game.make_move(move, ' ')
            if score > best_score:
                best_score = score
                best_move = move
            alpha = max(alpha, best_score)
        return best_move

    def minimax(self, game, maximizing_player, alpha, beta):
        if game.is_winner('O'):
            return 1
        elif game.is_winner('X'):
            return -1
        elif game.is_board_full():
            return 0

        if maximizing_player:
            max_eval = -math.inf
            for move in game.available_moves():
                game.make_move(move, 'O')
                eval = self.minimax(game, False, alpha, beta)
                game.make_move(move, ' ')
                max_eval = max(max_eval, eval)
                alpha = max(alpha, eval)
                if beta <= alpha:
                    break
            return max_eval
        else:
            min_eval = math.inf
            for move in game.available_moves():
                game.make_move(move, 'X')
                eval = self.minimax(game, True, alpha, beta)
                game.make_move(move, ' ')
                min_eval = min(min_eval, eval)
                beta = min(beta, eval)
                if beta <= alpha:
                    break
            return min_eval

def play_game(game_type):
    if game_type == 'TicTacToe':
        game = TicTacToe()
    elif game_type == 'DotsAndBoxes':
        game = DotsAndBoxes()
    elif game_type == 'ConnectFour':
        game = ConnectFour()

    bot = GameBot(game_type)

    while not game.game_over():
        game.print_board()
        if game.num_empty_cells() % 2 == 0:  # Bot's turn
            move = bot.get_next_move(game)
            game.make_move(move, 'O')
            print(f"Bot placed 'O' at position {move}")
        else:  # Player's turn
            move = input("Your turn. Enter move: ")
            game.make_move(move, 'X')

    game.print_board()
    if game.is_winner('O'):
        print("Bot wins!")
    elif game.is_winner('X'):
        print("You win!")
    else:
        print("It's a tie!")

if __name__ == "_main_":
    play_game('TicTacToe')  # Change the game type here